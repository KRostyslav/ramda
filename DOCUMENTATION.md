# Документація

- [__](#__) `Function`
- [add](#add) `Math`
- [addIndex](#addindex) `Function`
- [adjust](#adjust) `List`
- [all](#all) `List`
- [allPass](#allpass) `Logic`
- [always](#always) `Function`
- [any](#any) `List`
- [anyPass](#anypass) `List`
- [compose](#compose) `Function`
- [identity](#identity) `Function`
- [into](#into) `List`
- [none](#none) `List`
- [pipe](#pipe) `Function`
- [reduce](#reduce) `List`
- [reduced](#reduced) `List`
- [reduceRight](#reduceright) `List`
- [subtract](#subtract) `Math`
- [transduce](#transduce) `List`
- [update](#update) `List`


________

## __
### `[Function]`

_Додано у версії v0.6.0_

Спеціальне значення, для визначення "прогалин" у каррованих функціях,
яке дає змогу частковому застосуванню будь-якої комбінації аргументів, в незалежності від їх позицій.

Якщо `g` - це каррована тернарна функція і `_` є `R.__`, тоді наступне евівалентне:

- `g(1, 2, 3)`
- `g(_, 2, 3)(1)`
- `g(_, _, 3)(1)(2)`
- `g(_, _, 3)(1, 2)`
- `g(_, 2, _)(1, 3)`
- `g(_, 2)(1)(3)`
- `g(_, 2)(1, 3)`
- `g(_, 2)(_, 3)(1)`

```javascript
var greet = R.replace('{name}', R.__, 'Hello, {name}!');
greet('Alice'); //=> 'Hello, Alice!'
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20greet%20%3D%20R.replace%28%27%7Bname%7D%27%2C%20R.__%2C%20%27Hello%2C%20%7Bname%7D%21%27%29%3B%0Agreet%28%27Alice%27%29%3B%20%2F%2F%3D%3E%20%27Hello%2C%20Alice%21%27)



## add
### `[Math]`

`Number → Number → Number`

#### Параметри:
| a |
:---|
| b |
| повертає __Number__ |

_Додано у версії v0.1.0_

Додає два значення

Дивіться також [subtract](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#subtract).

```javascript
R.add(2, 3);       //=>  5
R.add(7)(10);      //=> 17
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#;R.add%282%2C%203%29%3B%20%20%20%20%20%20%20%2F%2F%3D%3E%20%205%0AR.add%287%29%2810%29%3B%20%20%20%20%20%20%2F%2F%3D%3E%2017)

**[⬆ вверх](#Документація)**



## addIndex
### `[Function]`

`((a … → b) … → [a] → *) → (a …, Int, [a] → b) … → [a] → *)`

#### Параметри:
| fn | Функція ітерації списку, що не передає індекс чи список у функцію зворотнього виклику(callback) |
:---|:---|
| повертає __function__ | Змінена функція ітерації списку, що не передає (елемент, індекс, список)  у його функцію зворотнього виклику(callback) |

_Додано у версії v0.15.0_

Створює нову функцію ітерації списку з уже існуючої, за допомогою додавання двох нових аргументів до функції зворотнього виклику: теперішній індекс і весь список.

Це, в свою чергу, перетворить, наприклад функцію `R.map` у функцію, яка більше нагадує `Array.prototype.map`. Зверніть увагу на те, що це спрацює лише для функцій, в яких ітеруюча функція зворотнього виклику є першим аргументом, а список - останнім. (Останнє може бути не важливим, якщо аргумент списку не використовується.)

```javascript
var mapIndexed = R.addIndex(R.map);
mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
//=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#;var%20mapIndexed%20%3D%20R.addIndex%28R.map%29%3B%0AmapIndexed%28%28val%2C%20idx%29%20%3D%3E%20idx%20%2B%20%27-%27%20%2B%20val%2C%20%5B%27f%27%2C%20%27o%27%2C%20%27o%27%2C%20%27b%27%2C%20%27a%27%2C%20%27r%27%5D%29%3B%0A%2F%2F%3D%3E%20%5B%270-f%27%2C%20%271-o%27%2C%20%272-o%27%2C%20%273-b%27%2C%20%274-a%27%2C%20%275-r%27%5D)

**[⬆ вверх](#Документація)**



## adjust
### `[List]`

`(a → a) → Number → [a] → [a]`

#### Параметри:
| fn | Функція яка буде застосована |
:---|:---|
| idx | Індекс |
| list | Масиво-подібний об'єкт, чиє значення буде замінено на вказаному за індексом місці. |
| повертає __Array__ | Копію переданого масиво-подібного об'єкту, з елементом (на місці згідно з індексом `idx`) заміненим значенням яке повернулось після застосування функції `fn` до існуючого елемента. |

_Додано у версії v0.14.0_

Застосовує функцію до вказаного за індексом елемента у масиві, повертаючи нову копію масиву з елементом, на вказаному за індексом місці, заміненим результатом застосованої функції.

Дивіться також [update](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#update).

```javascript
R.adjust(R.add(10), 1, [1, 2, 3]);     //=> [1, 12, 3]
R.adjust(R.add(10))(1)([1, 2, 3]);     //=> [1, 12, 3]
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.adjust%28R.add%2810%29%2C%201%2C%20%5B1%2C%202%2C%203%5D%29%3B%20%20%20%20%20%2F%2F%3D%3E%20%5B1%2C%2012%2C%203%5D%0AR.adjust%28R.add%2810%29%29%281%29%28%5B1%2C%202%2C%203%5D%29%3B%20%20%20%20%20%2F%2F%3D%3E%20%5B1%2C%2012%2C%203%5D)

**[⬆ вверх](#Документація)**



## all
### `[List]`

`(a → Boolean) → [a] → Boolean`

#### Параметри:
| fn | Функція предикат |
:---|:---|
| list | Масив, який має бути оцінений. |
| повертає __Boolean__ | `true`, якщо предикат вдовольняється кожним з елементів, в іншому випадку повернеться `false`. |

_Додано у версії v0.1.0_

Повертає `true`, якщо всі елементи списку відповідають предикату, `false`, якщо у списку немає жодного який би відповідав.

Застосовує до всіх метод другого аргументу, якщо він присутній.

Діє як перетворювач(трансдюсер), якщо трансформер зазначений на місці списку.

Дивіться також [any](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#any), [none](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#none), [transduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#transduce).

```javascript
var equals3 = R.equals(3);
R.all(equals3)([3, 3, 3, 3]); //=> true
R.all(equals3)([3, 3, 1, 3]); //=> false
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20equals3%20%3D%20R.equals%283%29%3B%0AR.all%28equals3%29%28%5B3%2C%203%2C%203%2C%203%5D%29%3B%20%2F%2F%3D%3E%20true%0AR.all%28equals3%29%28%5B3%2C%203%2C%201%2C%203%5D%29%3B%20%2F%2F%3D%3E%20false)

**[⬆ вверх](#Документація)**



## allPass
### `[Logic]`

`[(*… → Boolean)] → (*… → Boolean)`

#### Параметри:
| predicates | масив предикатів, які необхідно перевірити |
:---|:---|
| повертає __function__ | об'єднаний предикат |

_Додано у версії v0.9.0_

Приймає список предикатів і повертає предикат, який повертає `true` для заданого списку аргументів, якщо кожен з переданих предикатів задовольяється тими аргументами.

Повернута функція є каррованою, чия арність співпадає з арністю предиката з найвищою арністю.

Дивіться також [anyPass](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#anypass)

```javascript
var isQueen = R.propEq('rank', 'Q');
var isSpade = R.propEq('suit', '♠︎');
var isQueenOfSpades = R.allPass([isQueen, isSpade]);

isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#;var%20isQueen%20%3D%20R.propEq%28%27rank%27%2C%20%27Q%27%29%3B%0Avar%20isSpade%20%3D%20R.propEq%28%27suit%27%2C%20%27%E2%99%A0%EF%B8%8E%27%29%3B%0Avar%20isQueenOfSpades%20%3D%20R.allPass%28%5BisQueen%2C%20isSpade%5D%29%3B%0A%0AisQueenOfSpades%28%7Brank%3A%20%27Q%27%2C%20suit%3A%20%27%E2%99%A3%EF%B8%8E%27%7D%29%3B%20%2F%2F%3D%3E%20false%0AisQueenOfSpades%28%7Brank%3A%20%27Q%27%2C%20suit%3A%20%27%E2%99%A0%EF%B8%8E%27%7D%29%3B%20%2F%2F%3D%3E%20true)

**[⬆ вверх](#Документація)**



## always
### `[Function]`

`a → (* → a)`

#### Параметри:
| val | Значення, яке необхідно обгорнути у функцію |
:---|:---|
| повертає __function__ | функція :: * -> val. |

_Додано у версії v0.1.0_

Повертає функцію, яка завжди повертає передане значення. __Зауважте__, що для не примітивів поертаєме значення буде посиланням а оригінальне значення.

Ця функція відома як `const`, константа, чи K (для K комбінатор) у інших мовах та бібліотеках.

```javascript
var t = R.always('Tee');
t(); //=> 'Tee'
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20t%20%3D%20R.always%28%27Tee%27%29%3B%0At%28%29%3B%20%2F%2F%3D%3E%20%27Tee%27)

**[⬆ вверх](#Документація)**



## any
### `[List]`

`(a → Boolean) → [a] → Boolean`

#### Параметри:
| fn | Функція предикат |
:---|:---|
| list | Масив, який має бути оцінений. |
| повертає __Boolean__ | `true`, якщо предикат вдовольняє хоча б один з елементів, в іншому випадку повернеться `false`. |

_Додано у версії v0.1.0_

Повертає `true`, якщо бодай один елемент списку відповідає предикату, в іншому випадку поверне `false`.

Застосовує до будь-якого методу другого аргументу, якщо він присутній.

Діє як перетворювач(трансдюсер), якщо трансформер зазначений на місці списку.

Дивіться також [all](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#all), [none](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#none), [transduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#transduce).

```javascript
var lessThan0 = R.flip(R.lt)(0);
var lessThan2 = R.flip(R.lt)(2);
R.any(lessThan0)([1, 2]); //=> false
R.any(lessThan2)([1, 2]); //=> true
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#;var%20lessThan0%20%3D%20R.flip%28R.lt%29%280%29%3B%0Avar%20lessThan2%20%3D%20R.flip%28R.lt%29%282%29%3B%0AR.any%28lessThan0%29%28%5B1%2C%202%5D%29%3B%20%2F%2F%3D%3E%20false%0AR.any%28lessThan2%29%28%5B1%2C%202%5D%29%3B%20%2F%2F%3D%3E%20true)

**[⬆ вверх](#Документація)**



## anyPass
### `[Logic]`

`[(*… → Boolean)] → (*… → Boolean)`

#### Параметри:
| predicates | масив предикатів, які необхідно перевірити |
:---|:---|
| повертає __function__ | об'єднаний предикат |

_Додано у версії v0.9.0_

Приймає список предикатів і повертає предикат, який повертає `true` для заданого списку аргументів, якщо хоча б один з переданих предикатів задовольяється тими аргументами.

Повернута функція є каррованою, чия арність співпадає з арністю предиката з найвищою арністю.

Дивіться також [allPass](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#allpass)

```javascript
var isClub = R.propEq('suit', '♣');
var isSpade = R.propEq('suit', '♠');
var isBlackCard = R.anyPass([isClub, isSpade]);

isBlackCard({rank: '10', suit: '♣'}); //=> true
isBlackCard({rank: 'Q', suit: '♠'}); //=> true
isBlackCard({rank: 'Q', suit: '♦'}); //=> false
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20isClub%20%3D%20R.propEq%28%27suit%27%2C%20%27%E2%99%A3%27%29%3B%0Avar%20isSpade%20%3D%20R.propEq%28%27suit%27%2C%20%27%E2%99%A0%27%29%3B%0Avar%20isBlackCard%20%3D%20R.anyPass%28%5BisClub%2C%20isSpade%5D%29%3B%0A%0AisBlackCard%28%7Brank%3A%20%2710%27%2C%20suit%3A%20%27%E2%99%A3%27%7D%29%3B%20%2F%2F%3D%3E%20true%0AisBlackCard%28%7Brank%3A%20%27Q%27%2C%20suit%3A%20%27%E2%99%A0%27%7D%29%3B%20%2F%2F%3D%3E%20true%0AisBlackCard%28%7Brank%3A%20%27Q%27%2C%20suit%3A%20%27%E2%99%A6%27%7D%29%3B%20%2F%2F%3D%3E%20false)

**[⬆ вверх](#Документація)**



## compose
### `[Function]`

`((y → z), (x → y), …, (o → p), ((a, b, …, n) → o)) → ((a, b, …, n) → z)`

#### Параметри:
| ...functions | Функції, які мають бути складені. |
:---|:---|
| повертає __function__ | Складену функцію |

_Додано у версії v0.1.0_

Виконує складання функції справа наліво. Крайня права функція може мати будь-яку арність, а інші функції повинні бути унарними.

__Зауважте:__ Результат методу `compose` не каррується автоматично.

Дивіться також [pipe](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#pipe).

```javascript
var classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
var yellGreeting = R.compose(R.toUpper, classyGreeting);
yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"

R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20classyGreeting%20%3D%20%28firstName%2C%20lastName%29%20%3D%3E%20%22The%20name%27s%20%22%20%2B%20lastName%20%2B%20%22%2C%20%22%20%2B%20firstName%20%2B%20%22%20%22%20%2B%20lastName%0Avar%20yellGreeting%20%3D%20R.compose%28R.toUpper%2C%20classyGreeting%29%3B%0AyellGreeting%28%27James%27%2C%20%27Bond%27%29%3B%20%2F%2F%3D%3E%20%22THE%20NAME%27S%20BOND%2C%20JAMES%20BOND%22%0A%0AR.compose%28Math.abs%2C%20R.add%281%29%2C%20R.multiply%282%29%29%28-4%29%20%2F%2F%3D%3E%207)

**[⬆ вверх](#Документація)**



## identity
### `[Function]`

`a → a`

#### Параметри:
| x | Значення яке повернути. |
:---|:---|
| повертає __*__ | Введене значення `x` |

_Додано у версії v0.1.0_

Функція, яка нічого не робить, але повертає переданий в неї аргумент. Гарно підходить, щоб бути функцією за замовчуванням чи функцією-заповнювачем.

```javascript
R.identity(1); //=> 1

var obj = {};
R.identity(obj) === obj; //=> true
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.identity%281%29%3B%20%2F%2F%3D%3E%201%0A%0Avar%20obj%20%3D%20%7B%7D%3B%0AR.identity%28obj%29%20%3D%3D%3D%20obj%3B%20%2F%2F%3D%3E%20true)

**[⬆ вверх](#Документація)**



## into
### `[List]`

`a → (b → b) → [c] → a`

#### Параметри:
| acc | Початкове значення накопичувача. |
:---|:---|
| xf | Функція-перетворювач. Отримує трансформер і повертає трансформер. |
| list | Список, який потрібно перебрати. |
| повертає __*__ | Остаточне накопичене значення |

_Додано у версії v0.12.0_

Перетворює елементи списку за допомогою перетворювача(transducer) і додає трансформовані елементи до накопичувача, використовуючи відповідну функцію-ітератор в залежності від типу накопичувача.

Накопичувач може бути масивом, об'єктом чи трансформером. Перебрані елементи буде додано до масивів і об'єднано у строки. Об'єкти будуть об'єднані безпосередньо чи масиви з двома елементами будуть об'єднані у вигляді пар ключ-значення.

Накопичувач(акумулятор) може також бути об'єктом-трансформером, який абезпечує бінарність(2-арність) зменшення функції-ітератора, крок(step), нулярність(0-арність) початкового значення функціх, ініт(init), та унарність(1-арність) результату функції-витягнення, результат(result). Функція step використовується в якості функції-ітератора у методі reduce. Функція result використовується для перетворення кінцевого накопичувача у повертаємий тип і у більшості випадків являється `R.identity`. Функція init використовується для передачі початкового накопичувача.

Ітерації виконуються за допомогою `R.reduce` після ініціалізації перетворювача(transducer).

```javascript
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));

R.into([], transducer, numbers); //=> [2, 3]

var intoArray = R.into([]);
intoArray(transducer, numbers); //=> [2, 3]
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%5D%3B%0Avar%20transducer%20%3D%20R.compose%28R.map%28R.add%281%29%29%2C%20R.take%282%29%29%3B%0A%0AR.into%28%5B%5D%2C%20transducer%2C%20numbers%29%3B%20%2F%2F%3D%3E%20%5B2%2C%203%5D%0A%0Avar%20intoArray%20%3D%20R.into%28%5B%5D%29%3B%0AintoArray%28transducer%2C%20numbers%29%3B%20%2F%2F%3D%3E%20%5B2%2C%203%5D)

**[⬆ вверх](#Документація)**



## none
### `[List]`

`(a → Boolean) → [a] → Boolean`

#### Параметри:
| fn | Функція предикат |
:---|:---|
| list | Масив, який має бути оцінений. |
| повертає __Boolean__ | `true`, якщо предикат не вдовольняє жоден з елементів, в іншому випадку повернеться `false`. |

_Додано у версії v0.12.0_

Повертає `true`, якщо жоден елемент списку не відповідає предикату, в іншому випадку поверне `false`.

Застосовує до кожного методу другого аргументу, якщо він присутній.

Дивіться також [all](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#all), [any](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#any).

```javascript
var isEven = n => n % 2 === 0;

R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
R.none(isEven, [1, 3, 5, 7, 8, 11]); //=> false
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20isEven%20%3D%20n%20%3D%3E%20n%20%25%202%20%3D%3D%3D%200%3B%0A%0AR.none%28isEven%2C%20%5B1%2C%203%2C%205%2C%207%2C%209%2C%2011%5D%29%3B%20%2F%2F%3D%3E%20true%0AR.none%28isEven%2C%20%5B1%2C%203%2C%205%2C%207%2C%208%2C%2011%5D%29%3B%20%2F%2F%3D%3E%20false)

**[⬆ вверх](#Документація)**



## pipe
### `[Function]`

`(((a, b, …, n) → o), (o → p), …, (x → y), (y → z)) → ((a, b, …, n) → z)`

#### Параметри:
| ...functions |
:---|
| повертає __function__ |

_Додано у версії v0.1.0_

Виконує складання функції зліва направо. Крайня ліва функція може мати будь-яку арність, а інші функції повинні бути унарними.

В деяких бібліотеках ця функція називається `sequence`.

__Зауважте:__ Результат методу `pipe` не каррується автоматично.

Дивіться також [compose](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#compose).

```javascript
var f = R.pipe(Math.pow, R.negate, R.inc);

f(3, 4); // -(3^4) + 1
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20f%20%3D%20R.pipe%28Math.pow%2C%20R.negate%2C%20R.inc%29%3B%0A%0Af%283%2C%204%29%3B%20%2F%2F%20-%283%5E4%29%20%2B%201)

**[⬆ вверх](#Документація)**



## reduce
### `[List]`

`((a, b) → a) → a → [b] → a`

#### Параметри:
| fn | Функція-ітератор. Отримує два значення, накопичувач(аккумулятор) і поточний елемент з масиву. |
:---|:---|
| acc | Значення накопичувача. |
| list | Список, який потрібно перебрати. |
| повертає __*__ | Остаточне накопичене значення |

_Додано у версії v0.1.0_

Під час ітерації(перебору) списку повертає єдиний елемент, послідовно викликаючи функцію-ітератор і передаючи їй значення акумулятора і поточне значення з масиву, а потім передає результат до наступного виклику.

Функція-ітератор отримує два значення: _(acc, value)_. Вона може використовувати `R.reduced` для комбінації ітерації.

Порядок аргументів у функції-ітераторі `reduceRight` є таким: _(value, acc)_.

**Зауважте:** `R.reduce` не пропускає видалені чи нерозподілені індекси(розріджені масиви), на відміну від вбудованого в javascript методу `Array.prototype.reduce`. Більш детальну інформацію, щодо цієї поведінки дивіться тут: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description)

Якщо присутній третій аргумент він також передається у метод `reduce`. При цьому, залежить від користувача, що робити з `R.reduced`, оскільки це не реалізовано у `reduce`.

Дивіться також [reduced](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduced), [addIndex](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#addIndex), [reduceRight](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduceright).

```javascript
R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
          -               -10
         / \              / \
        -   4           -6   4
       / \              / \
      -   3   ==>     -3   3
     / \              / \
    -   2           -1   2
   / \              / \
  0   1            0   1
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.reduce%28R.subtract%2C%200%2C%20%5B1%2C%202%2C%203%2C%204%5D%29%20%2F%2F%20%3D%3E%20%28%28%28%280%20-%201%29%20-%202%29%20-%203%29%20-%204%29%20%3D%20-10%0A%2F%2F%20%20%20%20%20%20%20%20%20%20-%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-10%0A%2F%2F%20%20%20%20%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%20%20%20%20%20-%20%20%204%20%20%20%20%20%20%20%20%20%20%20-6%20%20%204%0A%2F%2F%20%20%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%20%20%20-%20%20%203%20%20%20%3D%3D%3E%20%20%20%20%20-3%20%20%203%0A%2F%2F%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%20-%20%20%202%20%20%20%20%20%20%20%20%20%20%20-1%20%20%202%0A%2F%2F%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%200%20%20%201%20%20%20%20%20%20%20%20%20%20%20%200%20%20%201)

**[⬆ вверх](#Документація)**



## reduced
### `[List]`

`a → *`

#### Параметри:
| x | Фінальний результат `reduce`. |
:---|:---|
| повертає __*__ | Загорнуте значення |

_Додано у версії v0.15.0_

Повертає значення завернуте, щоб відзначити, що це остаточне значення функцій `reduce` та `transduce`. Значення, що повертається слід розглядати як чорний ящик: немає гарантій, що внутрішня структура стабільна.

**Зауважте:** ця оптимізація не доступна для функцій не перечислених вище. Наприклад, наразі немає підтримки `reduceRight`.

Дивіться також [reduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduce), [transduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#transduce).

```javascript
R.reduce(
 (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
 [],
 [1, 2, 3, 4, 5]) // [1, 2, 3]
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.reduce%28%0A%20%28acc%2C%20item%29%20%3D%3E%20item%20%3E%203%20%3F%20R.reduced%28acc%29%20%3A%20acc.concat%28item%29%2C%0A%20%5B%5D%2C%0A%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%29%20%2F%2F%20%5B1%2C%202%2C%203%5D)

**[⬆ вверх](#Документація)**



## reduceRight
### `[List]`

`(a, b → b) → b → [a] → b`

#### Параметри:
| fn | Функція-ітератор. Отримує два значення, поточний елемент з масиву і накопичувач(аккумулятор). |
:---|:---|
| acc | Значення накопичувача. |
| list | Список, який потрібно перебрати. |
| повертає __*__ | Остаточне накопичене значення |

_Додано у версії v0.1.0_

Під час ітерації(перебору) списку повертає єдиний елемент, послідовно викликаючи функцію-ітератор і передаючи їй значення акумулятора і поточне значення з масиву, а потім передає результат до наступного виклику.

Схожий на `reduce`, окрім того, що проходиться по переданому списку справа наліво.

Функція-ітератор отримує два значення: _(value, acc)_, в той час як послідовність аргументів у методі `reduce` - навпаки: _(acc, value)_.

**Зауважте:** `R.reduceRight` не пропускає видалені чи нерозподілені індекси(розріджені масиви), на відміну від вбудованого в javascript методу `Array.prototype.reduceRight`. Більш детальну інформацію, щодо цієї поведінки дивіться тут: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description)

Дивіться також [reduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduce), [addIndex](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#addIndex).

```javascript
R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
    -               -2
   / \              / \
  1   -            1   3
     / \              / \
    2   -     ==>    2  -1
       / \              / \
      3   -            3   4
         / \              / \
        4   0            4   0
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.reduceRight%28R.subtract%2C%200%2C%20%5B1%2C%202%2C%203%2C%204%5D%29%20%2F%2F%20%3D%3E%20%281%20-%20%282%20-%20%283%20-%20%284%20-%200%29%29%29%29%20%3D%20-2%0A%2F%2F%20%20%20%20-%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20-2%0A%2F%2F%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%201%20%20%20-%20%20%20%20%20%20%20%20%20%20%20%201%20%20%203%0A%2F%2F%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%202%20%20%20-%20%20%20%20%20%3D%3D%3E%20%20%20%202%20%20-1%0A%2F%2F%20%20%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%20%20%203%20%20%20-%20%20%20%20%20%20%20%20%20%20%20%203%20%20%204%0A%2F%2F%20%20%20%20%20%20%20%20%20%2F%20%5C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%20%5C%0A%2F%2F%20%20%20%20%20%20%20%204%20%20%200%20%20%20%20%20%20%20%20%20%20%20%204%20%20%200)

**[⬆ вверх](#Документація)**



## subtract
### `[Math]`

`Number → Number → Number`

#### Параметри:
| a | перший аргумент |
:---|:---|
| b | другий аргумент |
| повертає __Number__ | Результат `a-b` |

_Додано у версії v0.1.0_

Віднімає свій другий аргумент від першого.

Дивіться також [add](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#add).

```javascript
R.subtract(10, 8); //=> 2

var minus5 = R.subtract(R.__, 5);
minus5(17); //=> 12

var complementaryAngle = R.subtract(90);
complementaryAngle(30); //=> 60
complementaryAngle(72); //=> 18
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#;R.subtract%2810%2C%208%29%3B%20%2F%2F%3D%3E%202%0A%0Avar%20minus5%20%3D%20R.subtract%28R.__%2C%205%29%3B%0Aminus5%2817%29%3B%20%2F%2F%3D%3E%2012%0A%0Avar%20complementaryAngle%20%3D%20R.subtract%2890%29%3B%0AcomplementaryAngle%2830%29%3B%20%2F%2F%3D%3E%2060%0AcomplementaryAngle%2872%29%3B%20%2F%2F%3D%3E%2018)

**[⬆ вверх](#Документація)**



## transduce
### `[List]`

`(c → c) → (a,b → a) → a → [b] → a`

#### Параметри:
| xf | Функція-перетворювач. Отримує трансформер і повертає трансформер. |
:---|:---|
| fn | Функція-ітератор. Отримує два значення, накопичувач(аккумулятор) і поточний елемент з масиву. За необхідності, загорнутий як трансформер і використовується для ініціалізації перетворювача |
| acc | Початкове значення накопичувача. |
| list | Список, який потрібно перебрати. |
| повертає __*__ | Остаточне накопичене значення |

_Додано у версії v0.12.0_

Ініціалізує перетворювач, використовуючи передану функцію-ітератор. Повертає єдиний елемент перебираючи список, послідовно викликаючи перетворену функцію-ітератор і передаючи їй значення акумулятора і поточне значення з масиву, а потім передає результат до наступного виклику.

Функція ітератор отримує два значення: _`(acc, value)`_ (накопичувач та значення). Вона буде загорнута як трансформер для ініціалізації перетворювача. Трансформер може бути переданий безпосередньо на місці функції-ітератора. У обох випадках ітерація може бути достроково зупинена функції `R.reduced`.

Перетворювач являє собою функцію, яка приймає трансформер, повертає трансформер і може бути зкладена(composed) безпосередньо.

Трансформер - це об'єкт, який забезпечує бінарне(2-арне) зменшення функції-ітератора, крок, нулярне(0-арне) початкове значення функції, init, та унарний (1-арний) результат функції витягання, результат. Функція крок використовується в якості функції-ітератора у зменшенні(reduce). Функція результат використовується для перетворення остаточного накопичення у повертаємий тип і у більшості випадків являється `R.identity`. Функція init може використовуватись для передачі початкового накопичувача, але ігнорується методом `transduce`.

Ітерації виконуються за допомогою `R.reduce` після ініціалізації перетворювача(transducer).

Дивіться також [reduce](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduce), [reduced](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#reduced), [into](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#into).

```javascript
var numbers = [1, 2, 3, 4];
var transducer = R.compose(R.map(R.add(1)), R.take(2));

R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?var%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%5D%3B%0Avar%20transducer%20%3D%20R.compose%28R.map%28R.add%281%29%29%2C%20R.take%282%29%29%3B%0A%0AR.transduce%28transducer%2C%20R.flip%28R.append%29%2C%20%5B%5D%2C%20numbers%29%3B%20%2F%2F%3D%3E%20%5B2%2C%203%5D)

**[⬆ вверх](#Документація)**



## update
### `[List]`

`Number → a → [a] → [a]`

#### Параметри:
| idx | Індекс, який необхідно оновити |
:---|:---|
| x | Значення, на яке має на зазначеному за індексом місці у масиві, що повернеться. |
| list | Цільовий масиво-подібний об'єкт, який має бути оновленим. |
| повертає __Array__ | A copy of `list` with the value at index `idx` replaced with `x`. |

_Додано у версії v0.14.0_

Повертає нову копію масиву з елементом(на вказаному за індексом місці) заміненим на передане значення.

Дивіться також [adjust](https://github.com/ivanzusko/ramda/blob/master/DOCUMENTATION.md#adjust).

```javascript
R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
```
Спробуйте у [REPL](http://ramdajs.com/repl/?v=0.24.1#?R.update%281%2C%2011%2C%20%5B0%2C%201%2C%202%5D%29%3B%20%20%20%20%20%2F%2F%3D%3E%20%5B0%2C%2011%2C%202%5D%0AR.update%281%29%2811%29%28%5B0%2C%201%2C%202%5D%29%3B%20%20%20%20%20%2F%2F%3D%3E%20%5B0%2C%2011%2C%202%5D)

**[⬆ вверх](#Документація)**
